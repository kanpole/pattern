# 游戏设计模式 (Game Design Patterns)

本项目使用C++实现了所有23种经典设计模式，以游戏开发为背景，展示每个模式的实际应用场景。所有代码都使用中文注释，便于理解和学习。

## 项目特点

- ✅ **完整性**: 实现了全部23种GoF设计模式
- 🎮 **游戏导向**: 所有示例都来自游戏开发场景  
- 📝 **中文注释**: 详细的中文注释，便于理解
- 🛠 **实用性**: 每个模式都有具体的游戏应用场景
- 🔧 **现代C++**: 使用C++17标准，采用智能指针等现代特性

## 项目结构

```
pattern/
├── CMakeLists.txt              # 构建配置
├── main.cpp                    # 主程序，演示所有模式
├── README.md                   # 项目说明
└── include/                    # 头文件目录
    ├── creational/             # 创建型模式
    │   ├── singleton.h         # 单例模式
    │   ├── factory_method.h    # 工厂方法模式
    │   ├── abstract_factory.h  # 抽象工厂模式
    │   ├── builder.h           # 建造者模式
    │   └── prototype.h         # 原型模式
    ├── structural/             # 结构型模式
    │   ├── adapter.h           # 适配器模式
    │   ├── bridge.h            # 桥接模式
    │   ├── composite.h         # 组合模式
    │   ├── decorator.h         # 装饰器模式
    │   ├── facade.h            # 外观模式
    │   ├── flyweight.h         # 享元模式
    │   └── proxy.h             # 代理模式
    └── behavioral/             # 行为型模式
        ├── chain_of_responsibility.h  # 责任链模式
        ├── command.h                  # 命令模式
        ├── observer.h                 # 观察者模式
        ├── state.h                    # 状态模式
        └── strategy.h                 # 策略模式
```

## 设计模式详解

### 创建型模式 (Creational Patterns)

#### 1. 单例模式 (Singleton Pattern)
- **应用场景**: 游戏管理器、资源管理器、配置管理器
- **实现**: 线程安全的单例，使用智能指针管理内存
- **特点**: 确保全局唯一实例，提供全局访问点

#### 2. 工厂方法模式 (Factory Method Pattern)  
- **应用场景**: 创建不同类型的敌人、武器、道具
- **实现**: 敌人工厂，支持哥布林、龙等不同敌人类型
- **特点**: 将对象创建延迟到子类，支持扩展

#### 3. 抽象工厂模式 (Abstract Factory Pattern)
- **应用场景**: 跨平台UI组件、不同主题的游戏资源
- **实现**: Windows/Mac UI工厂，创建平台相关的组件
- **特点**: 创建相关对象族，保证兼容性

#### 4. 建造者模式 (Builder Pattern)
- **应用场景**: 复杂游戏角色创建、关卡构建
- **实现**: 角色建造器，支持战士、法师等不同职业
- **特点**: 分步骤构建复杂对象，支持链式调用

#### 5. 原型模式 (Prototype Pattern)
- **应用场景**: 游戏对象克隆、子弹发射、粒子系统
- **实现**: 游戏对象池，通过克隆提高性能
- **特点**: 通过复制现有实例创建新对象

### 结构型模式 (Structural Patterns)

#### 6. 适配器模式 (Adapter Pattern)
- **应用场景**: 不同输入设备适配、第三方库集成
- **实现**: 键盘/手柄输入适配器，统一输入接口
- **特点**: 让不兼容的接口协同工作

#### 7. 桥接模式 (Bridge Pattern)
- **应用场景**: 游戏逻辑与渲染系统分离
- **实现**: 渲染器桥接，支持OpenGL/DirectX切换
- **特点**: 将抽象与实现分离，独立变化

#### 8. 组合模式 (Composite Pattern)
- **应用场景**: 游戏对象层次结构、UI组件树
- **实现**: 场景图，统一处理单个对象和组合对象
- **特点**: 树形结构，统一接口处理

#### 9. 装饰器模式 (Decorator Pattern)
- **应用场景**: 角色装备强化、技能buff、道具效果
- **实现**: 角色装饰器，动态添加武器、护甲等
- **特点**: 动态添加功能，不改变原有结构

#### 10. 外观模式 (Facade Pattern)
- **应用场景**: 简化复杂游戏引擎接口
- **实现**: 游戏引擎外观，封装图形、音频、物理等子系统
- **特点**: 提供简单接口，隐藏系统复杂性

#### 11. 享元模式 (Flyweight Pattern)
- **应用场景**: 大量相似对象优化、纹理共享、瓦片地图
- **实现**: 纹理管理器，多个精灵共享纹理数据
- **特点**: 通过共享减少内存使用

#### 12. 代理模式 (Proxy Pattern)
- **应用场景**: 资源懒加载、网络资源、访问控制
- **实现**: 资源代理，按需加载大型3D模型
- **特点**: 控制对象访问，增加额外功能

### 行为型模式 (Behavioral Patterns)

#### 13. 责任链模式 (Chain of Responsibility Pattern)
- **应用场景**: 事件处理系统、输入处理、伤害计算
- **实现**: 游戏事件处理链，依次处理输入、防御、伤害
- **特点**: 解耦发送者和接收者

#### 14. 命令模式 (Command Pattern)
- **应用场景**: 输入系统、撤销/重做、宏命令、AI指令
- **实现**: 游戏命令系统，支持移动、攻击、技能命令
- **特点**: 将请求封装为对象，支持撤销和排队

#### 15. 观察者模式 (Observer Pattern)
- **应用场景**: 事件系统、UI更新、成就系统
- **实现**: 玩家状态观察者，自动更新血条、经验条等UI
- **特点**: 一对多依赖，状态变化时自动通知

#### 16. 状态模式 (State Pattern)
- **应用场景**: 角色状态管理、游戏状态机、AI行为
- **实现**: 角色状态机，包含空闲、移动、跳跃、攻击等状态
- **特点**: 状态改变时改变行为

#### 17. 策略模式 (Strategy Pattern)
- **应用场景**: AI行为切换、不同难度算法
- **实现**: AI行为策略，包含巡逻、追击、攻击、逃跑等
- **特点**: 算法族可以相互替换

## 编译和运行

### 环境要求
- C++17兼容的编译器 (GCC 7+, Clang 5+, MSVC 2017+)
- CMake 3.10+

### 编译步骤

```bash
# 克隆项目
git clone <repository-url>
cd pattern

# 创建构建目录
mkdir build
cd build

# 生成构建文件
cmake ..

# 编译
make

# 运行程序
./patterns
```

### Windows编译
```cmd
mkdir build
cd build
cmake ..
cmake --build . --config Release
.\Release\patterns.exe
```

## 程序输出示例

程序运行时会依次演示每个设计模式：

```
欢迎来到游戏设计模式演示程序！
本程序将演示所有23种设计模式在游戏开发中的应用。

==================================================
  创建型模式演示
==================================================

1. 单例模式 (Singleton Pattern):
游戏管理器 - 当前分数: 100
游戏状态: 运行中

2. 工厂方法模式 (Factory Method Pattern):
创建敌人: Goblin (血量: 50)
创建敌人: Dragon (血量: 200)

...
```

## 学习建议

1. **循序渐进**: 建议按创建型 → 结构型 → 行为型的顺序学习
2. **实践为主**: 每个模式都有完整的代码实现，建议运行并修改代码
3. **理解场景**: 重点理解每个模式解决的问题和适用场景
4. **组合使用**: 实际项目中往往需要多个模式配合使用

## 扩展练习

1. 为现有模式添加新的具体实现
2. 尝试在自己的游戏项目中应用这些模式
3. 实现剩余的行为型模式（Iterator、Mediator、Memento等）
4. 优化现有实现，添加错误处理和边界检查

## 参考资料

- 《设计模式：可复用面向对象软件的基础》- GoF
- 《游戏编程模式》- Robert Nystrom
- 《Effective C++》- Scott Meyers

## 许可证

本项目采用MIT许可证，详见LICENSE文件。

## 贡献

欢迎提交Issue和Pull Request来完善这个项目！
